package com.ludamix.hxaudio.mock.timeline;

import com.ludamix.hxaudio.mock.timeline.TimelineEvent;

class Timeline
{

	public var default_value : Float;

	public function new(default_value : Float)
	{
		value = 0.;
		this.default_value = default_value;
		events = [];
	}
	
	public var events : Array<TimelineEvent>;
	public var value : Float;
	
	public function schedule(event : TimelineEvent)
	{
		// where events with specified begin times overlap and contain the exact same time, old events are replaced.
		// where events with specified end times overlap and contain the exact same time, old events are replaced.
		// setValueCurve is an exception to this, overlaps are simply not allowed.
		
		event.setTimeline(this);
		
		var i = 0;
		if (event.beginSpecified()) // this time has a known beginning, thus it can go "anywhere."
		{
			while (i < events.length) 
			{
				// Overwrite same event type and time.
				if (events[i].beginTime() == event.beginTime() && events[i].type() == event.type()) {
					events[i] = event;
					return;
				}

				if (events[i].beginTime() > event.beginTime())
					break;
				
				i += 1;
			}
			
			if (event.type() == TimelineEventValueCurve.TYPE && 
				i+1 < events.length &&
				events[i + 1].window().overlaps(event.window()))
				throw 	'ValueCurve from t=(${event.beginTime()},${event.endTime()})' +
						' illegally overlaps an event at time ${events[i + 1].beginTime()}.';
			if (events.length>0 && i < events.length &&
				events[i].type() == TimelineEventValueCurve.TYPE && 
				events[i].window().overlaps(event.window()))
				throw 	'ValueCurve from t=(${events[i - 1].beginTime()},${events[i - 1].endTime()})' +
						' illegally overlaps event pushed at time ${event.beginTime()}.';
			
		}
		else // it's an event appended "after" events with begin times; this describes the two tweening functions.
		{
			i = 0;
			if (events.length > 0)
			{
				if (events[i].endTime() == event.endTime() && !events[i].beginSpecified())
					events.remove(events[i]);
				if (events[i].beginTime() + events[i].duration() < event.endTime()) i += 1;
			}
		}
		events.insert(i, event);
		
		// Relink events.
		
		events[0].prev_event = null;
		events[0].recalcTime();
		for (n in 1...events.length)
		{
			events[n - 1].next_event = events[n];
			events[n].prev_event = events[n - 1];
			events[n].recalcTime();
		}
		events[events.length-1].next_event = null;
		events[events.length-1].recalcTime();
		
	}
	
	public function invalidEvent(event : TimelineEvent)
	{
		if (!event.beginSpecified()) return false;
		
		var i = 0;
		while (i < events.length) 
		{
			if (events[i].beginTime() > event.beginTime())
				break;
			i += 1;
		}
			
		if (event.type() == TimelineEventValueCurve.TYPE && 
			i+1 < events.length &&
			events[i + 1].window().overlaps(event.window())) return true;
		else return 
			(events.length>0 && i < events.length &&
				events[i].type() == TimelineEventValueCurve.TYPE && 
				events[i].window().overlaps(event.window()));
	}
	
	public function reset(startTime : Float)
	{
		var i = 0;
		while(i<events.length)
		{
			if (events[i].beginTime() >= startTime) { events.splice(i, 1); }
			else i+=1;
		}
		if (events.length > 0) events[events.length - 1].next_event = null;
	}
	
	public function toString():String
	{
		var r = "";
		for (e in events)
		{
			r += (e.toString())+"\n";
		}
		return r;
	}
	
	/**
	 * Internal fillFlat to cover the starts and ends.
	 */
	private inline function fillFlat(
		v : Float,
		start_curve : Int, end_curve : Int, 
		position : Int, 
		count : Int, write_offset : Int, buf : ArrayBuffer)
	{
		
		end_curve -= start_curve;
		count = Std.int(Math.min(end_curve, count));
		
		for (n in write_offset...count+write_offset)
		{
			buf.set(n, v);
		}
		value = v;
		return count;
	}
	
	/**
	 * Fill the buffer with samples generated by the given beginning and ending positions in the timeline.
	 */
	public function generate(begin : Int, end : Int, buf : ArrayBuffer, samplerate : Float)
	{
		var ms_sample_ratio = 100. / samplerate;
			
		var emit = begin;
		var playlength = end - begin;
		var t_start = 0.;
		var t_end = 0.;
		var i = 0;
		
		if (events.length == 0) 
		{
			fillFlat(value, begin, end, emit, playlength, 0, buf);
			return;
		}
		
		events[0].fillFromTime(emit, 0, playlength, buf, samplerate); 
		
		return;
		
	}

}
